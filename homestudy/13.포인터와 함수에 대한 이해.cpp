@함수의 인자로 배열 전달하기
함수라는 이름이 붙은 이유는
인자의 전달과 값의 반환이 가능하기 때문이다.

@값의 복사
인자전달의 기본 방식이다.
함수 호출 시 전달되는 인자의 값은 매개변수에 복사가 된다.
int simplefunc(int num) {...}

int main()
{
	int age = 17;
	simplefunc(age);   age에 저장된 값이 매개변수 num에 복사된다.
}
실제로 전달되는 것은 age가 아니라 age에 저장된 값이다.
매개변수로 배열을 선언할 수 없다.

배열을 통째로 넘겨받으려면 매개변수로 배열을 선언할 수 있어야 한다.

@배열을 함수의 인자로 전달하는 방식
ex)
void ShowArayElem(int* param, int len)
{
	int i;
	for (i = 0; i < len; i++)
		printf("%d".param[i]);
	printf("\n");
}
int main()
{
	int arr1[3] = { 1,2,3 };
	int arr2[5] = { 4,5,6,7,8 };
	ShowArayElem(arr1, sizeof(arr1 / sizeof(int));
	ShowArayElem(arr2, sizeof(arr2 / sizeof(int));
	return
		;
}
이처럼 배열의 주소 값만 안다면 어디서든 배열에 접근하여 저장된 값을 참조하고 변경할 수 있다.
== == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == =
@배열을 함수의 인자로 전달받는 함수 선언
void ShowArayElem(int* param, int len){...}
void ShowArayElem(int param[], int len)
이렇게 말이다.

int param[]과 int* param은 완전 동일한 선언이다.하지만 전자의 선언이, 배열이 인자로 전달된다는 느낌을 더 강하게 주는 선언이다.
따라서 일반적으로 배열의 주소값이 인자로 전달될 때에는 int param[]형태의 선언을 주로 사용한다.
하지만 이 둘이 같은 선언으로 간주되는 경우는 '매개변수의 선언'으로 제한된다.



하지만,
int arr[3] = { 1,2,3 };
int* ptr = arr;   이것을 int ptr[] = arr; 로는 불가능하다.
함수 내에서는 인자로 전달된 배열의 길이를 계산할 수 없기 때문에, 배열의 크기나 길이 정보도 함께 인자로 전달해야 한다.

== == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == =
call - by - value
값을 전달하는 형태의 함수 호출
우리가 정의한 대부분의 함수가 여기에 속한다.
ex)
void Swap(int ptr1, int ptr2)
{
	int temp = ptr1;
	ptr1 = ptr2;
	ptr2 = ptr1;
}
Swap(num1, num2)

call - by - reference
주소 값을 전달하는 형태의 함수 호출
ex)
void Swap(int* ptr1, int* ptr2)
{
	int temp = *ptr1;
	*ptr1 = *ptr2;
	*ptr2 = *ptr1;
}
Swap(&num1, &num2);

@scanf 함수 호출시 &연산자를 붙이는 이유
int num;
scanf("%d", %num);

scanf함수 호출이 완료되면 변수 num에는 값이 채워진다.
즉 프로그램 사용자로부터 값을 입력받아서 변수 num에 그 값을 채우는 일을 scanf함수가 한다.
이를 위해서 scanf함수는 변수 num의 주소 값을 알아야 한다.그래야 변수 num에 접근해서 값을 채울 수 있기 때문이다.
그래서 scanf함수 호출시 변수 num의 주소 값을 전달한다.

== == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == =
포인터 대상의 const 선언
포인터 변수가 참조하는 대상의 변경을 허용하지 않게 한다.
int num = 20;
const int* ptr = &num;
*ptr = 30;   -- 오류
num = 40;

포인터 변수 ptr을 이용해서 ptr이 가르키는 변수에 저장된 값을 변경하는 것을 허용하지 않겠다.
그렇다고 해서 포인터 변수 ptr이 가르키는 변수 num이 상수화되는 것은 아니다.

const의 선언 위치가 중요하다.

@포인터 변수의 상수화
int num1 = 20, num2 = 30;
int* const ptr = &num1;
ptr = &num2;  --에러
*ptr = 40;

포인터 변수 ptr이 상수라는 뜻은 한번 주소 값이 저장되면 그 값의 변경이 불가능하다는 뜻이며,
한번 가리키기 시작한 변수를 끝까지 가리켜야 한다는 뜻이다.

@const 선언이 갖는 의미
변수의 값을 변하지 않게하는 안정성이 있기 때문에, 값이 변경되는 오류를 막을 수 있다. 
코드의 안전성이 높아진다는 뜻이다.
이건 좋은 프로그래밍 습관이다.
