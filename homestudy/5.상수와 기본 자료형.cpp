자료형
데이터를 표현하는 방법이다.
때문에 변수와 상수도 자료형에 근거하다.

기본 자형의 종류와 데이터 표현 범위
자료형       이름                     크기                                       값의 표현범위
정수형      char                 1바이트(8bit) - 128이상 ± 127 이하
정수형      short                2바이트(16bit) - 32, 768이상 ± 32, 767 이하
정수형      int                   4바이트(32bit) - 21억 4783만 3648이상 ± 21억 4783만 3648 이하
정수형      long                 4바이트(32bit) - 21억 4783만 3648이상 ± 21억 4783만 3648 이하
정수형      long long          8바이트(64bit) - 922경 3372조 368억 5477만 5808이상 ±922경 3372조 368억 5477만 5808이상
실수형      float                 4바이트(32bit)              ±3.4 x10의 - 37승이상 ±3.4 x10의38승이상
실수형      double              8바이트(64bit)              ±1.7 x10의 - 307승이상 ±1.7 x10의308승이상
실수형      long double       8바이트(64bit) - double 이상의 표현범위
+
자료형 char는 1바이트(8비트)이므로 나타낼 수 있는 데이터의 종류가 2의 8승 = 256개이다.
따라서 - 128부터 + 127까지 표현된 자료다.

하지만,
자료형 별 크기는 정확히 제한하고 있지 않다.
컴파일러에 따라 약간의 차이를 보인다.

Q) 왜 이렇게 많은 자료형을 제공하는가 ?
1.데이터의 표현방식이 다르므로, 최소 둘 이상의 자료형이 필요하다.
2.메모리 공간의 적절한 사용을 위해서 다양한 크기의 자료형이 필요하다.

@정수를 표현 및 처리하기 위한 일반적인 자료형
일반적으로 CPU가 처리하기 가장 적합한 크기의 정수 자료형을 int로 정의힌다.
그렇기 때문에, int보다 작은크기의 데이터는 int형 데이터로 바꿔서(형 변환) 연산이 진행된다.

Q) 그럼 char형 변수화 shor형 변수는 필요없나요 ?
"데이터의 양이 많아서 연산속도보다 데이터의 크기를 줄이는 것이 더 중요한 데이터들"  ex) mp3
위와 같은 상황일 땐 char형, short형 변수가 유용하게 사용된다.

@실수를 표현 및 처리하기 위한 일반적인 자료형
표준으로 double 자료형을 사용한다.

실수 자료형의 선택에 있어서 '정밀도'가 가장 중요하다.
float        6자리 (소수점 이하 정밀도)  4바이트
double      15자리 (소수점 이하 정밀도)  8바이트
long double 18자리 (소수점 이하 정밀도)  12바이트

+ double 형 데이터를 출력할땐 서식문자 '%f' 를 사용하지만, 데이터를 입력 받을 땐 서식문자 %lf를 사용한다.

@unsigned란?
양의 정수만 표현 가능해진다.
정수 자료형의 이름 앞에만 사용가능하다.
msb도 데이터의 크기를 표현하는데 사용한다.
표현 할 수 있는 값이 2배로 늘어난다.

Q) signed도 사용하나요 ?
다른 정수 자료형들과 달리 'char'는 signed char와 다른 선언일 수도 있다.
unsigned char로 처리하는 컴파일러도 존재하기 때문이다.
이런 이유로 char형 변수를 선언해, 음의 정수를 저장하는 경우에는 signed 선언을 추가한다.

unsigned 선언을 포함하는 정수 자료형의 보편적인 크기
자료형       이름                                        크기                                       값의 표현범위
정수형      char                                    1바이트(8bit) - 128이상 ± 127 이하
정수형      unsigned char                       1바이트(8bit)                             0이상 255이하
정수형      short                                   2바이트(16bit) - 32, 768이상 ± 32, 767 이하
정수형      unsigned short                      2바이트(16bit)                           0이상 65, 535이하
정수형      int                                      4바이트(32bit) - 21억 4783만 3648이상 ± 21억 4783만 3648 이하
정수형      unsigned int                         4바이트(32bit)                        0이상(21억 4783만 3648 + 21억 4783만 3648)이하
정수형      long                                   4바이트(32bit)                                          //
정수형      unsigned long                      4바이트(32bit)                                          //
정수형      long long                            8바이트(64bit) - 922경 3372조 368억 이상 ±922경 3372조 368억이하
정수형      unsigned long long               8바이트(64bit)                        0이상(922경 3372조 368억 + 922경 3372조 368억)이상

@문자의 표현방식과 문자를 위한 자료형
아스키 코드 (ASCII)
숫자를 이용해서 문자를 표현하도록 숫자를 문자에 연결시키는 방법이다.
+ 아스키 코드는 '미국 표준 협회(ANSI: American National Standards Institute)'에서 제정했다.

+ 아스키 코드를 구성하는 값의 범위는 0이상 127이하이다.따라서 1바이트로 표현 가능하다.
+ 알파벳 대문자와 소문자간의 값의 차는 32이다.ex) 문자 A = 65, 문자a = 97

@문자가 표현되는 방식
int main(void)
{
	char ch1 = 'A', ch2 = 65;
	int ch3 = 'Z', ch4 = 90;

	printf("%c* %d \n", ch1, ch1);
	printf("%c %d \n", ch2, ch2);
	printf("%c %d \n", ch3, ch3);
	printf("%c %d \n", ch4, ch4);
	return 0;
}

*' %c ' 란 ?
문자의 형태로 데이터를 출력 또는 입력하라는 뜻을 지닌 서식문자

따라서 정수는 출력의 방법에 따라서 문자의 형태로도, 숫자의 형태로도 출력이 가능하다.

Q) int형으로 선언하면 더 빠른데, 문자도 int형 변수에 저장해야 되는거 아닌가 ?
int형 변수가 빠른 것은 '연산'인데, 문자로는 연산할 일이 없다.
때문에 문서를 저장하는 데에는 char형 변수가 적합하다.

Q2) char는 문자형 ? 정수형 ?
답은 정수형이다.
문자의 표현을 목적으로 정의된 자료형이기 때문에 '문자형'으로 분류되기도 하지만,
결국 문자도 정수의 형태로 표현이 되고, 실제로 char형 변수에 저장되는 것은 정수이기 때문이다.

프로그램 상에서 문자표현에는 작은 따옴표가 사용된다.

== == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == ==
상수
변경이 불가능한 데이터를 뜻한다.

이름 있는 상수*와 이름 없는 상수*로 나뉜다.
int와 double 같은 자료형을 근거로 표현된다.

리터럴 상수(Literal)
이름이 없는 상수
int num = 20 + 30;

위 덧셈의 단계별 과정
1.정수 20과 30이 메모리 공간에 상수의 형태로 저장된다.
2.두 상수를 기반으로 덧셈이 진행된다.
3.덧셈의 결과로 얻어진 정수 50이 변수 num에 저장된다.
int num1 = 1 + 5;
int num2 = 9 + num1;
double num3 = 3.64 + 6.11;

변수의 수는 num1, num2, num3 총 3개, 상수의 수는 정수형 상수와 실수형 상수를 포함 1, 5, 9, 3.64, 6.11 총 5개.

#리터럴 상수의 자료형
메모리상에 저장되는 모든 데이터는 자료형이 결정되어야 한다.
그래야 저장하는 방법이 정해지기 때문이다.

ex)
int inum = 10;            // 정수형 상수
double dnum = 3.14 // 실수형 상수

int형으로 표현 가능한 정수형 상수는 int형으로 메모리 공간에 저장하기로 약속되어 있다.
double형으로 표현 가능한 실수형 상수는 double형으로 메모리 공간에 저장하기로 약속되어 있다.

+ 대입 연산자의 왼편에 있는 변수의 자료형에 따라서 상수가 결정되는 것이 아니다.
대입 연산자의 오른편에 선언된 상수의 자료형에 어울리게 변수의 자료형을 선언하는 것이다.!!

+ 리터럴 상수의 크기 또한 sizeof 연산자를 이용해 확인할 수 있다.

@접미사를 이용한 다양한 상수의 표현
#정수형 상수의 표현을 위한 접미사
접미사     자료형                   사용의 예
U                 unsigned int                      unsigned int n = 1034U
L                  long                                     long n = 2465L
UL               unsigned long                    unsigned long n = 3164UL
LL                long long                            long long n = 5641LL
ULL             unsigned long long           unsigned long long n = 8966ULL

#실수형 상수의 표현을 위한 접미사
접미사     자료형                   사용의 예
F                   float                                   float f = 3.14F
L            long double            long double f = 5.465L

const 상수(심볼릭 상수)(symbolic)
변수 선언 시 const 선언만 추가해주면 된다.
단, 이는 상수이므로 선언과 동시에 초기화를 해야 한다.
const int MAX = 100;        // MAX 는 상수! 값의 변경 불가!     
const double PI = 3.1415;  // PI 는 상수! 값의 변경 불가!

+변수와 상수의 구분을 용이하기 하는데 목적이 있는 관례
상수의 이름은 모두 대문자로 표시하고,
둘 이상의 단어로 연결할 때에는 MY_AGE와 같이 언더바를 이용해 두 단어를 구분하는 것이 관례
== == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == =
자료형의 반환
데이터의 표현방식을 바꾸는 것이다.
자동 형 변환(묵시적 형 변환)
강제 형 변환(명시적 형 변환)

@대입연산의 전달과정에서 발생하는 자동 형 변환
대입 연산자 왼편과 오른편에 존재하는 두 피연산자의 자료형이 일치하지 않으면, 왼편에 있는 피연산자를 대상으로 형 변환이 자동으로 발생

double num1 = 245;   // int형 정수 245를 double형으로 자동 형 변환
int num2 = 3.1415;    // double형 정수 3.1415를 int형으로 자동 형 변환

+정수를 실수로 형 변환하는 경우
실수의 표현범위가 정수에 비해 훨씬 넓기 때문에 데이터의 손실 발생x
다만, 실수의 표현이기 때문에 오차는 존재하게 된다.

+ 실수를 정수로 형 변환하는 경우
'소수부의 손실'이 발생한다. == 소수점 이하의 값은 버려진다.

+ 바이트 크기가 큰 정수를 바이트 크기가 작은 정수로 형 변환하는 경우
'상위 바이트 손실'이 발생한다.
변환하고자 하는 정수의 바이트 크기에 맞춰 상위 바이트를 단순히 소멸시킨다.
그리고 이로인해 부호가 바뀔 수도 있으니, 주의해야 한다.

@묵시적 형 변환
int num = 3.1415;    double형 실수 3.1415를 int형으로 자동 형변환
실수형 데이터를 정수형 데이터로 변환하는 과정에는 '소수부의 손실'이 발생한다.

정수의 승격(intergral promotion)d에 의한 묵시적 형 변환
int보다 작은 크기의 정수형 데이터는 int형 데이터로 형 변환이 되어서 연산이 되는데,
이러한 형태의 형 변환을 가르켜 '정수의 승격'이라 한다.

Q) 정말 int형 연산이 short형 연산보다 빠를까 ?
과거에는 CPU의 구조 때문에 그랬지만,
요즘은 CPU의 성능과 구조가 이전과는 달리 많이 개선되어서, 정수형 데이터의 연산속도를 사실상 차이가 나지 않는다.

short num1 = 15, num2 = 25;
short num3 = num1 + num2;  num1, num2가 int형으로 형 변환된다.

피연산자 불일치로 발생하는 형변환
피연산자의 자료형이 일치하지 않아서 발성하는 자동 형 변환은 
데이터의 손실을 최소화하는 방향으로 진행된다.
int -> long -> long long -> float -< double -> long double
이와 같이 형 변환의 우선순위는 정수 자료형보다 실수 자료형이 무조건 앞서는 형태로 정의된다.

Q) char와 short가 생략된 이유는 ?
'정수의 승격'에 의해서 둘 다 int로 형 변환되기에 생략되었다.


@명시적 형 변환
형 변환 연산자를 이용해서 강제로 형 변환을 명령하는 것을 의미한다.

연산결과의 자료형은 피연산자의 자료형과 일치한다.
따라서 원하는 형 변환을 제대로 하기 위해선 '형 변환 연산자'를 사용한다.
int num1 = 3, num2 = 4;
double divResult;
divResult = num1 / num2;
printf("나눗셈 결과: %f \n", divResult);
return 0;
--------------------
0.000000
연산결과의 자료형은 피연산자의 자료형과 일치한다.

int num1 = 3, num2 = 4;
double divResult;
divResult = (double*)num1 / num2;
printf("나눗셈 결과: %f \n", divResult);
return 0;
----------------
0.75
(type casting operator)
형 변환 연산자
() 괄호를 사용해 연산자 우선순위를 바꿔주기도 하고, 형을 변환해주기도 한다.
result = (double)num1 / num2

+ 형 변환 연산자(type casting operator)
형 변환을 명령할 때 사용되는 소괄호를 가르킨다.

ex)*(double)num1