변수(variable)
값을 저장할 수 있는 메모리 공간이다.

변수의 선언과 초기화
int num;   변수 num 선언
num = 12;  변수 num을 12로 초기화

Int* num*;  //num이라는 이름의 변수 선언

*int 정수의 저장이 가능한 메모리 공간을 할당
*num 그 메모리 공간의 이름을 num이라 한다.

#include <stdio.h> // 헤더파일 불러오기

Int main(void) // 메인함수
{
	int num;
	num = 90;
	Printf("%d", num);
	Return 0;
}

int num = 12; 변수 num을 12로 초기화

@변수의 초기화*
*초기화란 ?
선언된 변수에 처음 값을 저장하는 것을 말한다.
+ 선언과 동시에 초기화도 가능하다.

ex)
int num; // num이라는 변수의 선언
num = 12; // 변수 num을 12로 초기화
Int num2 = 30;  num2라는 변수를 선언, 30으로 초기화

@쓰레기값
아무런 의미가 없는 값을 뜻한다.
변수를 선언만 하고 초기화하지 않으면 쓰레기 값이 저장된다.

+ 변수에 쓰레기값이 저장되지 않는 것이 좋으므로, 변수를 선언과 동시에 0으로 초기화 한 다음,
의미있는 값을 저장하기도 한다.
int a, b;
a = 10;
b = a;
저장 공간으로 사용하는 변수 =  l-value  left value
값으로 사용하는 변수        =  r-value right value

Int		num1 = 0;
예약어  식별자

예약어(reserved word or keyword) - 컴파일러와 사용 방법이 약속된 단어
식별자(identifier)				 - 필요에 따라 사용하는 단어


변수 선언 주의사항
1.중괄호 안에서 선언할 경우, 변수의 선언문은 중괄호의 앞부분에 위치해야 한다.

변수명 지을 때 주의사항
1.변수의 이름은 알파벳, 숫자, (_)언더바로 구성된다.
2.대소문자를 구분해서 사용한다.
3.숫자로 시작할 수없고, 특정 키워드도 사용 금지다.
4.이름 사이에 공백 불가
5.특수문자 사용x


+ 변수의 이름을 정할 때에는 변수의 역할에 어울리는, 의미 있는 이름을 지어야 한다.

변수의 형태를 자료형이라 한다.

변수의 자료형(data type)
정수형 변수 - 정수의 저장을 목적으로 선언된 변수
실수형 변수

정수인지, 실수인지에 따라 메모리 공간에 저장 및 참조되는 방식이 다르다.

연산자(operator)
특정 연산을 요구할 때 사용하는 약속된 기호이다.

Q) 이항연산자(binary operator)란 ?
두 개의 피연산자를 요구하는 연산자를 말한다.

#대입 연산자(= )와 산술 연산자(+, -, *, / , %)->이항연산자
= -연산자 오른쪽 값을 연산자 왼쪽에 있는 변수에 대입
+ -두 연산자의 값을 더함
- -왼쪽의 피연산자 값에서 오른쪽 피연산자 값을 뺌
*   -두 피연산자의 값을 곱함
/ -왼쪽의 피연산자 값에서 오른쪽 피연산자 값으로 나눔
%   -왼쪽의 피연산자 값에서 오른쪽 피연산자 값을 뺀 나머지


#복합 대입 연산자
A += b == a + b = b
A -= b == a + -b = b
A *= b == a * b = b
A /= b == a / b = b
A %= b == a % b = b

+ 주의사항
복합 대입 연산자를 사용할때 대입(= )은 뒤에 붙여야 한다.
Num1 = -num2;  // 이건 num1 = -num2;
Num1 -= num2  // 이건 num1 - num2; 

#증감연산자
변수에 저장된 값을 1 증가 및 감소시키는 경우에 사용되는 연산자이다.

++num   선 증가, 후 연산
Num++   선 연산, 후 증가
--num    선 감소, 후 연산
Num--    선 연산, 후 감소

전위표기(prefix), 후위표기(postfix)

Ex)
Int num1 = 5;
Int num2 = 8;

Printf("num1: %d \n", num1);
Printf("num1++: %d \n", num1++);  //선 연산, 후 증가 = 후위 증가
Printf("num1: %d \n\n", num1);

Printf("num2: %d \n", num2);
Printf("num2: %d \n", ++num2); // 선 증가, 후 연산 = 전위 증가
Printf("num2: %d \n", num2);
Return 0;

Num1: 5
	Num1++ : 6
	Num1 : 6

	Num2 : 8
	++Num2 : 9
	Num2 : 9

	+ 후위증가나 후위감소 연산 시에는 소괄호의 영향을 받지 않고,
	다음 문장으로 넘어가야지만 값의 증가 및 감소가 이뤄진다.

	#관계 연산자(비교 연산자) (<, >, == , != , <= , >= )
	대소와 동등의 관계를 따지는 연산자이다.
	<      ex) n1 < n2  n1이 n2보다 작은가 ?
	>      ex) n1 <= n2  n1이 n2보다 큰가 ?
	== ex) n1 >= n2 n1과 n2가 같은가 ?

	!= ex) n1 != n2  n1과 n2는 다른가 ?
	<= ex) n1 <= n2  n1이 n2보다 같거나 작은가 ?
	>= ex) n1 >= n2 n1이 n2보다 같거나 큰가 ?

	관계연산자들은
	조건을 만족하면 1을, 만족하지 않으면 0를 반환한다.
	조건을 만족하면 '참(true)'을, 만족하지 않으면 '거짓(false)'를 반환한다.

	참 = 1
	거짓 = 0

논리 연산자(&&, || , !)
AND(논리곱) ex) A&&B A와 B가 같으면 참을 반환
OR(논리합)  ex) A || B A와 B 둘 중 하나라도 참이면 참을 반환
NOT(논리부정)ex) !A  A가 거짓이면 참, 참이면 거짓을 반환
+
OR(논리합) 'll' 연산은 연산자 앞에 있는 피연산자가 '참'이 나오면 그대로 그대로 연산결과를 '참'으로 반환한다.

&&와 ||연산자는 short circuit rule 적용된다
좌항만으로 연산 결과를 판별하는 기능

#콤마 연산자(, )
다른 연산자들과는 다르게 '구분'을 목적으로 주로 사용된다.

둘 이상의 변수를 동시에 선언하거나, 둘 이상의 문장을 한 행(line)에 삽입할 때,
둘 이상의 인자를 함수로 전달할 때 인자의 구분을 목적으로 사용된다.
콤마 연산자 - 왼쪽부터 연산을 시작하고, 가장 오른쪽의 피연산자가 최종 값이다

#비트연산자(&, l, ^, ~, << , >> )
주로 하드웨어 관련 프로그래밍에 활용된다.
메모리 공간의 효율성을 높이고 연산의 수를 줄이는 요인이 되기도 한다.

& 비트단위로 AND 연산                                                                                                                                   ex) num1 & num2;
l   비트단위로 OR 연산                                                                                     ex) num1 l num2;
^ 비트단위로 XOR 연산                                                                                   ex) num1 ^ num2;
~단항 연산자로서 피연산자의 모든 비트를 반전시킨다.ex) ~num;  // num은 변화없음, 반전결과만 변환 
<< 피연산자의 비트 열을 왼쪽으로 이동시킨다.  #쉬프트 연산자*(비트 이동 연산자)       ex)num << 2; //num 변화x, 두칸 왼쪽 이동결과반환
>> 피연산자의 비트 열을 오른쪽을 이동 시킨다. #쉬프트 연산자(비트 이동 연산자)        ex)num << 2; //num 변화x, 두칸 올쪽 이동결과반환

*쉬프트 연산자는 비트연산자의 범주에 포함되어 있다.


#
&연산자: 비트단위 AND
두 개의 비트가 모두 1일때 1을 반환하는 연산
0 & 0   0반환
0 & 1  0 반환
1 & 0   0반환
1 & 1   1반환

#
l 연산자 : 비트단위 OR
두 개의 비트 중 하나라도 1이면 1을 반환하는 연산
0 l 0  0 반환
0 l 1  1 반환
1 l 0  1 반환
1 l 1  1 반환

#
^연산자: 비트단위 XOR
두 개의 비트가 서로 다른 경우에 1을 반환하는 연산
0 ^ 0  0 반환
0 ^ 1  1 반환
1 ^ 0  1 반환
1 ^ 1  0 반환

#
~연산자: 비트단위 NOT
비트를 0에서 1로, 1에서 0으로 반전시키기 때문에 보수연산이라고도 불림
~0  1 반환
~1  0 반환

+ 비트부호도 반전된다.

#
<< 연산자 : 비트의 왼쪽 이동(Shift)
두 개의 피연산자를 요구하며  다음의 의미를 갖는다.
num1 << num2  num1의 비트 열을 num2칸씩 왼쪽으로 이동시킨 결과를 반환
8 << 2      정수 8의 비트 열을       2칸씩 왼쪽으로 이동시킨 결과를 반환

ex)
int num = 10;   //  00000000 00000000 00000000 00001010

int result1 = num << 1;  //num의 비트 열을 왼쪽으로 1칸씩 이동 
int result1 = num << 2;  //num의 비트 열을 왼쪽으로 2칸씩 이동 
int result1 = num << 3;  //num의 비트 열을 왼쪽으로 3칸씩 이동

result 1 = 20
result 2 = 40
result 3 = 60

비트의 열을 왼쪽으로 1칸씩 이동할 때마다, 정수의 값은 두 배가 된다.

#
>> 연산자 : 비트의 오른쪽 이동(Shift)

Q) 비트를 오른쪽 으로 n칸 이동할 때, 만약 MSB가 1이 였다면 ?
CPU에 따라 0이 채워지거나, 1이 채워진다.

비트의 열을 왼쪽으로 1칸씩 이동할 때마다, 정수의 값은 두 배가 된다.

sizeof 연산자
자료형의 크기를 확인할 때 사용한다.
메모리 공간에서 소모하는 메모리의 크기를 바이트 단위로 계산해서 반환한다.

int num = 10;
int sz1 = sizeof(num);  // 변수 num의 크기를 계산하여 sz1을 초기화
int sz2 = sinzeof(int);   // 변수 int의 크기를 계산하여 sz1을 초기화

형 변환 연산자
(자료형) 피연산자
(double)10 -> 10.0
@연산자 우선순위와 결합방향
연산자에는 우선순위가 있다.
Ex) 논리 연산자보다 관계 연산자가 먼저 진행이 된다.

우선순위가 동일한 두 연산자가 하나의 수식에 존재하는 경우, 어떠한 순서대로 연산하느냐를 결정하는 것은
'결합방향'이다.
- 단항 연산자 > 이항 연산자 > 삼항 연산자
- 산술 연산자 > 비트 이동 연산자 > 관계 연산자 > 논리 연산자
우선순위가 같으면, 왼쪽부터.단 대입과 단항연산자는 오른쪽에서 왼쪽으로
연산자 순서가 애매하면 주저없이 괄호 사용

연산자 우선순위와 결합방향 표 참조

scanf 함수(입력 함수)
int num;
scanf("%d", &num);   키보드로 입력된 정수를 변수 num에 저장
&= = ampersand(앰퍼샌드)

%d는 10진수의 정수형태로 입력받는다는 뜻.
scanf 함수는 공백을 기준으로 데이터를 구분한다.
따라서 여러개를 입력받을 땐, %d를 띄워줘야함.
ex) scanf("%d %d %d", &a, &b, &c);

Q) 변수 num 앞에 &가 붙는 이유 ?
포인터와 함수에 대해 심층 공부해야 알 수 있다.

Ex)
Int result;
Int num1, num2;

Printf("정수 a: ");
Scanf("%d", &a);   //첫번째 정수 입력
Printf("정수 b: ");
Scanf("%d", &b);   // 두번째 정수 입력

Result = num1 + num2;
Printf(%d + %d = %d \n, num1, num2, result);
Return 0;

@입력의 형태를 다양하게 지정할 수 있다.
ex)1번 데이터 = 10진수 정수 형태
2번 데이터 = 16진수 정수 형태

+ scanf 함수는 공백을 기준으로 데이터를 구분하므로, 정수 사이에 공백을 넣어줘야 한다.
 
연산식 처리과정
sum = a+ b의 연산과정
메모리에 있는 a와 b의 값을 cpu의 저장공간인 레지스터에 복사, 이 과정을 로드(load)라고 한다.
연산 명령 이전에 수행된다.(1번, 2번) 데이터가 레지트서에 저장되면 연산장치인 ALU에 의해 덧셈 연산이 수행되고
그 결과값이 레지스터에 저장된다(3번). 이후 대입 연산을 수행하면 메모리 공간인 SUM에 복사되어 모든 과정 완료.(4번)
이 과정을 스토어(store)라 한다.	

     cpu									   메모리
     10 					    <-(로드)	 10 변수 a
	 20					     	<-(로드)     20 변수 b
	 30(레지스터, CPU저장장치)  ->(스토어)   30 변수 num
  ALU(CPU의 연산장치)   

