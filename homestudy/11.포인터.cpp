포인터
주소 값의 저장을 목적으로 선언되는 포인터 변수이다.
주소를 저장하는 일정한 크기의 메모리 공간
주소 == 상수
포인터 == 변수
주소와 포인터의 크기 sizeof 연산자 활용

ex) int num = 7;
int* pnum;     포인터 변수 pnum의 선언
pnum = &num;   num의 주소값을 포인터 변수 pnum에 저장

포인터 변수 pnum이 int형 변수 num을 가르킨다.

@포인터 변수의 크기
32비트 시스템에는 주소 값을 32비트로 표현하기 때문에 4바이트
64비트 시스템에는 주소 값을 64비트로 표현하기 때문에 8바이트

@포인터 변수 선언
int* pnum1;    int*은 int형 변수를 가르키는 pnum1의 선언을 의미한다.

@포인터형(type)
int, char, double, type을 사용한다.

== == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == ==
@포인터 관련 연산자(&, *)
&연산자(adress operator) (ampersand operator)
변수의 주소 값을 반환한다.
주소는 16진수로 출력한다.

포인터가 가르키는 변수의 형태가 같아야 대입 가능
->형 변환으로 포인터의 대입 가능
41.포인터 사용 이유
임베디드 프로그래밍을 할 때 메모리에 직접 접근하는 경우,
동적 할당된 메모리를 사용하는 경우

int num = 5;
int* pnum = &num;    num의 주소 값을 반환하여 포인터 변수 pnum을 초기화한다.

이때 피연산자는 변수이어여 하며, 상수는피연산자가 될 수 없다.
또한 변수의 자료형에 맞지 않는 포인터 변수의 선언은 문제가 될 수 있다.

*연산자(Asterisk operator)
포인터가 가르키는 메모리를 참조하는 연산자이다.
역참조 연산자라고 부르기도 한다.

ex)
int num = 10; 
int* pnum = &num;  포인터 변수 pnum이 변수 num을 가르키게 한다.
*pnum = 20;        pnum이 가르키는 변수에 20을 저장한다.
printf("%d", *pnum); pnum이 가르키는 변수를 부호 있는 정수로 출력한다.

포인터의 형은 메모리 공간을 참조하는 기준이 된다.
== == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == ==
잘못된 포인터의 사용과 널 포인터
int* ptr;    포인터 변수 ptr은 쓰레기 값으로 초기화
*ptr = 200;         
ptr이 어디를 가르키는 위치인지 몰라서 값을 저장할 수 없다.

따라서,
int* ptr1=nullptr 로 초기화해준다.
이는 0을 가르키는 게 아니라, 아무것도 가르키지 않는다.
