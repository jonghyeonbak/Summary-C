@선행 처리기와 매크로

#실행파일 생성 과정에서의 선행처리
소스파일(int main ...)->선행처리기(전처리기)->전처리기를 거친 소스파일(int main ...) ->
컴파일러->오프젝트 파일(01010101010110)->링커 - > 실행파일

전처리기가 실행하는 일은 단순하다.
선행처리 명령문대로 소스코드의 일부를 수정하는 것이다.
수정은 단순 치환(substitution)의 형태를 띈다.
#define PI  3.14
컴파일러가 아닌 선행처리기에 의해 처리되는 문장이기 때문에 명령문 끝에 세미콜론 x
위 명령문은 선행처리기에게 이런 메시지를 보낸다
"PI를 만나면 인정사정 볼 것 없이 3.14로 치환해라!"

'선행처리'는 컴파일 이전의 처리를 의미한다.
따라서 소스파일은 컴파일러에 의해서 컴파일 되기 이전에,
선행처리기에 의해서 선행처리의 과정을 거치게 된다고 이야기 한다.

@대표적인 선행처리 명령문
#define: Object-like macro

#define PI 3.414
지시자 매크로 매크로 몸체

선행처리기는 지시자를 보고 프로그래머가 지시하는 바를 파악한다.
"매크로 PI를 매크로 몸체 3.1415로 전부 치환하라!"

PI라는 매크로는 그 자체로 상수가 된다.
따라서 이와 같은 매크로를 '오브젝트와 유사한 매크로' 또는 '매크로상수' 라 한다.
#define NAME "홍길동"
#define AGE  24
#define PRINT_ADDR   puts("주소: 경기도 용인시\n");

printf("이름: %s \n", NAME);
printf("나이: %d \n", AGE);
PRINT_ADDR;

#define: Function-like-macro
"함수와 유사한 매크로", '매크로 함수'
#define SQUARE(X) X*X

매크로 확장(macro expension)
선행처리기에 의해서 변환되는 과정 자체
#define SQUARE(X) X*X
int num = 20;
printf("%d \n", SQUARE(num);
printf("%d \n", SQUARE(-5);

@잘못된 매크로 정의
printf("%d \n", SQUARE(3+2);
3 + 2 * 3 + 2

int num = 120 / SQUARE(2)
= 120;
옳바른 정의
#define SQUARE(X) ((X)*(X))

@가독성을 위한 매크로 두 줄 정의
#define SQUARE(X) \
((X)*(X))

역슬러쉬 뒤에 아무것도 안오게 조심하자

@매크로 정의 시 먼저 정의된 매크로 사용 가능
#define PI 3.14
#define CIRCLE_AREA(R) ((PRODUCT(R), (R))*PI)
double rad = 2.1;
printf("반지름 %g인 원의 넓이: %g \n", rad, CIRCLE_AREA(rad));
->반지름 2.1인 원의 넒이 : 13.8474

@매크로 함수의 장점
일반 함수보다 실행 속도가 빠르다
자료형에 따라 별도의 함수를 정의하지 않아도 된다

매크로 함수는 선행처리기에 의해 매크로 함수의 몸체 부분이 매크로 함수의 호출 문장을
대신하기 때문에 속도가 빠르다.

전달인자의 자료형에 상관없이 제대로 치환된다.

@매크로 함수의 단점
정의하기 까다롭다
디버깅하기 어렵다
#define DIFFABS(a, b) ((a)>(b) ? (a)-(b):(b)-(a))
매크로 함수를 잘못 정의할 경우, 에러 메세지는 선행처리 이후의 소스파일을 기준으로 출력된다.
따라서 일반적인 에러 메시지보다 이해하기 힘들다

@매크로 함수로 정의하는 예시
작은 크기의 함수
호출 빈도수가 높은 함수

크기가 작아야 매크로 형태로 정의가 편하고, 에러 발생 확률이 낮다.
호출의 빈도수가 높아야 성능 향상의 이점을 더욱 잘 누릴 수 있다.

@조건부 컴파일(Conditional Compilation)을 위한 매크로
#if... #endif: 참이라면
#ifdef...#endif: 정의되었다면
#ifndef... #endif: 정의되지 않았다면

else는 셋 다 사용가능
elif(else if)는 #if에만 사용 가능

@매개변수의 결합과 문자열화
#문자열 내에서는 매크로의 매개변수 치환 발생 x
#define STRING_JOB(A,B) "A의 직업은 B입니다."
STRING_JOB(민수, 벌레) ->"A의 직업은 B입니다."

@문자열 내에서 매크로의 매개변수 치환 발생하게 만들기
#연산자
#define STR(ABC)  #ABC
"매개변수 ABC에 전달되는 인자를 문자열 "ABC"로 치환해라!"
STR(123) -> "123"

char* str = "ABC", "DEF";
char* str = "ABCDEF"
동일하다

#define STRING_JOB(A, B) #A "의 직업은" #B "입니다."
printf("%s \n"STRING_JOB(민수, 나무꾼));
printf("%s \n"STRING_JOB(선녀, 사슴));
-> "민수" "의 직업은" "나무꾼" "입니다."
-> "민수의 직업은 나무꾼 입니다."

@필요한 형태대로 단순하게 결합하기
매크로 ## 연산자
#define CON(UPP, LOW) UPP ## 00 ## LOW
int num = CON(22, 77);
-> int num = 220077;

보통 하나의 프로그램은 독립적으로 컴파일 가능한 파일 단위인 모듈(module)로 나누어 분할 컴파일한다.
#pragma 지시자
컴파일러의 컴파일 방법을 세부적으로 제어할 때 사용한다.
사용법은 지시명directive-name을 통해 컴파일러의 어떤 기능을 제어할지 알려준다.
pack은 구조체의 패딩 바이트 크기를 결정하며, warning은 경고 메시지를 관리한다.
